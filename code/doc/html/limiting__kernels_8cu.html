<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>dg: src/limiting/limiting_kernels.cu File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">dg
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_4c97a4b019c38afa84e9a9e43bdbc881.html">limiting</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">limiting_kernels.cu File Reference<div class="ingroups"><a class="el" href="group__limiting.html">Limiting</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Kernels used by the <a class="el" href="classLimiting.html">Limiting</a> class.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="limiting__kernels_8h_source.html">limiting_kernels.h</a>&quot;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="loopstart_8h_source.html">loopstart.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="loop_8h_source.html">loop.h</a>&quot;</code><br/>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aa475ffaee4695d0cbfb87c71fc1642eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa475ffaee4695d0cbfb87c71fc1642eb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOOP_END</b>&#160;&#160;&#160;N_Y</td></tr>
<tr class="separator:aa475ffaee4695d0cbfb87c71fc1642eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de1a5f1c0cf262e0ff2e5f03d586abc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>MACRO</b>(x)</td></tr>
<tr class="separator:a5de1a5f1c0cf262e0ff2e5f03d586abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa475ffaee4695d0cbfb87c71fc1642eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa475ffaee4695d0cbfb87c71fc1642eb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOOP_END</b>&#160;&#160;&#160;N_Y</td></tr>
<tr class="separator:aa475ffaee4695d0cbfb87c71fc1642eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de1a5f1c0cf262e0ff2e5f03d586abc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5de1a5f1c0cf262e0ff2e5f03d586abc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MACRO</b>(x)&#160;&#160;&#160;for(int i=0; i&lt;N_s; i++){YC(x)[i] = U[(e*N_F+fcnt)*N_s+i];} fcnt++;</td></tr>
<tr class="separator:a5de1a5f1c0cf262e0ff2e5f03d586abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa475ffaee4695d0cbfb87c71fc1642eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa475ffaee4695d0cbfb87c71fc1642eb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOOP_END</b>&#160;&#160;&#160;N_Y</td></tr>
<tr class="separator:aa475ffaee4695d0cbfb87c71fc1642eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de1a5f1c0cf262e0ff2e5f03d586abc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5de1a5f1c0cf262e0ff2e5f03d586abc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MACRO</b>(x)&#160;&#160;&#160;<a class="el" href="limiting__kernels_8cu.html#a7af2f34a5759f1b77e868ab2e5745c23">set2average</a>(N_s,N,N_s1D,slicenum,L2M,M2L,tmp,YC(x),NULL);</td></tr>
<tr class="separator:a5de1a5f1c0cf262e0ff2e5f03d586abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa475ffaee4695d0cbfb87c71fc1642eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa475ffaee4695d0cbfb87c71fc1642eb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOOP_END</b>&#160;&#160;&#160;N_Y</td></tr>
<tr class="separator:aa475ffaee4695d0cbfb87c71fc1642eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de1a5f1c0cf262e0ff2e5f03d586abc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5de1a5f1c0cf262e0ff2e5f03d586abc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MACRO</b>(x)&#160;&#160;&#160;<a class="el" href="limiting__kernels_8cu.html#a7af2f34a5759f1b77e868ab2e5745c23">set2average</a>(N_s,N,N_s1D,slicenum,L2M,M2L,tmp,YC(x),NULL);</td></tr>
<tr class="separator:a5de1a5f1c0cf262e0ff2e5f03d586abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa475ffaee4695d0cbfb87c71fc1642eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa475ffaee4695d0cbfb87c71fc1642eb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOOP_END</b>&#160;&#160;&#160;N_Y</td></tr>
<tr class="separator:aa475ffaee4695d0cbfb87c71fc1642eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de1a5f1c0cf262e0ff2e5f03d586abc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>MACRO</b>(x)</td></tr>
<tr class="separator:a5de1a5f1c0cf262e0ff2e5f03d586abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa475ffaee4695d0cbfb87c71fc1642eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa475ffaee4695d0cbfb87c71fc1642eb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOOP_END</b>&#160;&#160;&#160;N_Y</td></tr>
<tr class="separator:aa475ffaee4695d0cbfb87c71fc1642eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de1a5f1c0cf262e0ff2e5f03d586abc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5de1a5f1c0cf262e0ff2e5f03d586abc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MACRO</b>(x)&#160;&#160;&#160;<a class="el" href="limiting__kernels_8cu.html#a3d80df4d636f90befb57ed3866618c8a">HR</a>(N_s,N,N_s1D,slicenum,L2M,M2L,tmp,YL(x),YC(x),YR(x),NULL);</td></tr>
<tr class="separator:a5de1a5f1c0cf262e0ff2e5f03d586abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa475ffaee4695d0cbfb87c71fc1642eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa475ffaee4695d0cbfb87c71fc1642eb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOOP_END</b>&#160;&#160;&#160;N_Y</td></tr>
<tr class="separator:aa475ffaee4695d0cbfb87c71fc1642eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de1a5f1c0cf262e0ff2e5f03d586abc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5de1a5f1c0cf262e0ff2e5f03d586abc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MACRO</b>(x)&#160;&#160;&#160;for(int i=0; i&lt;N_s; i++){Unew[(e*N_F+fcnt)*N_s+i] = YC(x)[i];} fcnt++;</td></tr>
<tr class="separator:a5de1a5f1c0cf262e0ff2e5f03d586abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa475ffaee4695d0cbfb87c71fc1642eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa475ffaee4695d0cbfb87c71fc1642eb"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>LOOP_END</b>&#160;&#160;&#160;N_Y</td></tr>
<tr class="separator:aa475ffaee4695d0cbfb87c71fc1642eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de1a5f1c0cf262e0ff2e5f03d586abc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5de1a5f1c0cf262e0ff2e5f03d586abc"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MACRO</b>(x)&#160;&#160;&#160;YL(x)=NULL; YC(x)=NULL; YR(x)=NULL;</td></tr>
<tr class="separator:a5de1a5f1c0cf262e0ff2e5f03d586abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a92518f2ffb1a46015396610a28b28ba9"><td class="memItemLeft" align="right" valign="top">arch_device void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a92518f2ffb1a46015396610a28b28ba9">getTaylorDerivative</a> (int order, int N_s, scalar *T, int mx, int my, int *DxIdx, int *DyIdx, scalar *ddT)</td></tr>
<tr class="separator:a92518f2ffb1a46015396610a28b28ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7ae4bf0d77b877b3793218f408ada8"><td class="memItemLeft" align="right" valign="top">arch_device scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a3b7ae4bf0d77b877b3793218f408ada8">CellAvg</a> (int N_G, int ioff, scalar *weight, scalar refArea, scalar *powers, int N_s, scalar *T)</td></tr>
<tr class="separator:a3b7ae4bf0d77b877b3793218f408ada8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8ecb63de1109255bb6a65c8f17d056"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b8ecb63de1109255bb6a65c8f17d056"></a>
arch_device int&#160;</td><td class="memItemRight" valign="bottom"><b>signum</b> (scalar val)</td></tr>
<tr class="separator:a4b8ecb63de1109255bb6a65c8f17d056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0069af8bc38d2f4e9ec19bf9df6be4ba"><td class="memItemLeft" align="right" valign="top">arch_device scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a0069af8bc38d2f4e9ec19bf9df6be4ba">minmod</a> (scalar a, scalar b)</td></tr>
<tr class="separator:a0069af8bc38d2f4e9ec19bf9df6be4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d976266542e5fef94a9c0bbcdaf4f4"><td class="memItemLeft" align="right" valign="top">arch_device scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a17d976266542e5fef94a9c0bbcdaf4f4">minabs</a> (scalar *c, int n)</td></tr>
<tr class="separator:a17d976266542e5fef94a9c0bbcdaf4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe1b556285d628a4b92b14110991cb5"><td class="memItemLeft" align="right" valign="top">arch_device scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#aafe1b556285d628a4b92b14110991cb5">minmod</a> (scalar *c, int n)</td></tr>
<tr class="separator:aafe1b556285d628a4b92b14110991cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0243447010f74e6a50a8c225ae3d616"><td class="memItemLeft" align="right" valign="top">arch_device scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#aa0243447010f74e6a50a8c225ae3d616">minmod2</a> (scalar *c, int n)</td></tr>
<tr class="separator:aa0243447010f74e6a50a8c225ae3d616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185f5abaa2b3c3d3c5614daa9b5032cb"><td class="memItemLeft" align="right" valign="top">arch_device int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a185f5abaa2b3c3d3c5614daa9b5032cb">lim_factorial</a> (int n)</td></tr>
<tr class="separator:a185f5abaa2b3c3d3c5614daa9b5032cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70986f580b196eef16d7cb91e47b6924"><td class="memItemLeft" align="right" valign="top">arch_device void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a70986f580b196eef16d7cb91e47b6924">limit_monomial</a> (int N, scalar *AL, scalar *AC, scalar *AR, scalar *Alim)</td></tr>
<tr class="separator:a70986f580b196eef16d7cb91e47b6924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4c481ca08e0e44963f4b155f58214df"><td class="memItemLeft" align="right" valign="top">arch_device int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#ac4c481ca08e0e44963f4b155f58214df">binomial_coefficient</a> (int n, int k)</td></tr>
<tr class="separator:ac4c481ca08e0e44963f4b155f58214df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ee51de8e63390db9d4cdeacab06f85"><td class="memItemLeft" align="right" valign="top">arch_device void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a13ee51de8e63390db9d4cdeacab06f85">gemm</a> (int M, int N, int K, scalar *A, scalar *B, scalar *C)</td></tr>
<tr class="separator:a13ee51de8e63390db9d4cdeacab06f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd47ab65df79fa19b17efac085afd87a"><td class="memItemLeft" align="right" valign="top">arch_device void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#acd47ab65df79fa19b17efac085afd87a">gemm3</a> (int M, int N, int K, scalar *A, scalar *B1, scalar *C1, scalar *B2, scalar *C2, scalar *B3, scalar *C3)</td></tr>
<tr class="separator:acd47ab65df79fa19b17efac085afd87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea1bee3e2f8ab6dedb101df367009e9"><td class="memItemLeft" align="right" valign="top">arch_device void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#afea1bee3e2f8ab6dedb101df367009e9">gemv</a> (int M, int N, scalar *A, scalar *B, scalar *C)</td></tr>
<tr class="separator:afea1bee3e2f8ab6dedb101df367009e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46545752cf7e2ea21dadfa32e45b9a9c"><td class="memItemLeft" align="right" valign="top">arch_device void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a46545752cf7e2ea21dadfa32e45b9a9c">gemv3</a> (int M, int N, scalar *A, scalar *B1, scalar *C1, scalar *B2, scalar *C2, scalar *B3, scalar *C3)</td></tr>
<tr class="separator:a46545752cf7e2ea21dadfa32e45b9a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc91d42c8f0af8dd56a56ed12b83de6"><td class="memItemLeft" align="right" valign="top">arch_device scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#acfc91d42c8f0af8dd56a56ed12b83de6">integrate_monomial_derivative</a> (int k, int n)</td></tr>
<tr class="separator:acfc91d42c8f0af8dd56a56ed12b83de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53b9b4a6c7794f2623344b129b18f62"><td class="memItemLeft" align="right" valign="top">arch_device scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#aa53b9b4a6c7794f2623344b129b18f62">integrate_monomial_derivative_bounds</a> (int k, int n, scalar a, scalar b)</td></tr>
<tr class="separator:aa53b9b4a6c7794f2623344b129b18f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac766dbf402ae6dba1b40a5c5a8825eb3"><td class="memItemLeft" align="right" valign="top">arch_device void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#ac766dbf402ae6dba1b40a5c5a8825eb3">average_monomial</a> (int N, scalar *A, scalar *Alim)</td></tr>
<tr class="separator:ac766dbf402ae6dba1b40a5c5a8825eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af2f34a5759f1b77e868ab2e5745c23"><td class="memItemLeft" align="right" valign="top">arch_device void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a7af2f34a5759f1b77e868ab2e5745c23">set2average</a> (int N_s, int N, int N_s1D, int slicenum, scalar *L2M, scalar *M2L, scalar *tmp, scalar *U, scalar *UMonoLim)</td></tr>
<tr class="separator:a7af2f34a5759f1b77e868ab2e5745c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d80df4d636f90befb57ed3866618c8a"><td class="memItemLeft" align="right" valign="top">arch_device void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a3d80df4d636f90befb57ed3866618c8a">HR</a> (int N_s, int N, int N_s1D, int slicenum, scalar *L2M, scalar *M2L, scalar *tmp, scalar *UL, scalar *UC, scalar *UR, scalar *UMonoLim)</td></tr>
<tr class="separator:a3d80df4d636f90befb57ed3866618c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7dfe81005a75c2551569cf06f784bc2"><td class="memItemLeft" align="right" valign="top">arch_device void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#ac7dfe81005a75c2551569cf06f784bc2">pressure</a> (int N_s, scalar *rho, scalar *rhou, scalar *rhov, scalar *E, scalar *gamma, scalar *beta, scalar *p)</td></tr>
<tr class="separator:ac7dfe81005a75c2551569cf06f784bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465b3c0c1d5008036a258c93801914dc"><td class="memItemLeft" align="right" valign="top">arch_device void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a465b3c0c1d5008036a258c93801914dc">kinetic_energy</a> (int N_s, scalar *L2M, scalar *rho, scalar *rhou, scalar *rhov, scalar *tmp, scalar *K)</td></tr>
<tr class="separator:a465b3c0c1d5008036a258c93801914dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7cc2e4f4ba2673dd8b464dfc4e5bbd0"><td class="memItemLeft" align="right" valign="top">arch_device void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#aa7cc2e4f4ba2673dd8b464dfc4e5bbd0">internal_energy</a> (int N_s1D, int slicenum, scalar *p, scalar *g, scalar *b, scalar *rhoe)</td></tr>
<tr class="separator:aa7cc2e4f4ba2673dd8b464dfc4e5bbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe1be35043c65e0741b29492605671b"><td class="memItemLeft" align="right" valign="top">arch_device void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#afbe1be35043c65e0741b29492605671b">reconstruct_total_energy</a> (int N_s, int N_s1D, int slicenum, scalar *L2M, scalar *M2L, scalar *rhoeLim, scalar *KLim, scalar *tmp, scalar *E)</td></tr>
<tr class="separator:afbe1be35043c65e0741b29492605671b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde8e1c7130bbae601ca57cfd9a9d711"><td class="memItemLeft" align="right" valign="top">arch_global void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#abde8e1c7130bbae601ca57cfd9a9d711">stridedcopy</a> (int numblocks, int blocklen, int strideA, int strideB, int offsetA, int offsetB, scalar *A, scalar *B)</td></tr>
<tr class="separator:abde8e1c7130bbae601ca57cfd9a9d711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0baf0fa343897a168db374263509330c"><td class="memItemLeft" align="right" valign="top">arch_global void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a0baf0fa343897a168db374263509330c">reconstruct_energy</a> (int N_s, int N_E, int slicenum, scalar *rhoeLim, scalar *KLim, scalar *EMono, scalar *ELim)</td></tr>
<tr class="separator:a0baf0fa343897a168db374263509330c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3739db4e71adf05a4bc800fc586ada30"><td class="memItemLeft" align="right" valign="top">arch_global void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a3739db4e71adf05a4bc800fc586ada30">internal_energy_multifluid</a> (int N_s, int N_E, int slicenum, scalar *p, scalar *g, scalar *rhoe)</td></tr>
<tr class="separator:a3739db4e71adf05a4bc800fc586ada30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ad14f9400d6a279f0f872f98d59654"><td class="memItemLeft" align="right" valign="top">arch_global void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#ad4ad14f9400d6a279f0f872f98d59654">internal_energy_stiffened</a> (int N_s, int N_E, int slicenum, scalar *p, scalar *g, scalar *b, scalar *rhoe)</td></tr>
<tr class="separator:ad4ad14f9400d6a279f0f872f98d59654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd23b3c7c438e768f4ec1ea600d7e87"><td class="memItemLeft" align="right" valign="top">arch_global void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a7fd23b3c7c438e768f4ec1ea600d7e87">hrl1D</a> (int N_s, int N_E, int Nfields, int N_N, int slicenum, int *neighbors, int offxy, scalar *A, scalar *Alim)</td></tr>
<tr class="separator:a7fd23b3c7c438e768f4ec1ea600d7e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511e708002c7b40970f0903239269fc5"><td class="memItemLeft" align="right" valign="top">arch_global void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a511e708002c7b40970f0903239269fc5">hri1D</a> (int N_s, int N_E, int N_N, int *neighbors, int N_s1D, int slicenum, int offxy, scalar *Lag2Mono, scalar *Mono2Lag, int *sensors, scalar *U, scalar *Unew)</td></tr>
<tr class="separator:a511e708002c7b40970f0903239269fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef8e65dda2bb15ed7cec0fbeb6a998a"><td class="memItemLeft" align="right" valign="top">arch_global void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a8ef8e65dda2bb15ed7cec0fbeb6a998a">m2i1D</a> (int N_s, int N_E, int N_N, int *neighbors, int N_s1D, int slicenum, int offxy, scalar *Lag2Mono, scalar *Mono2Lag, int *sensors, scalar *U, scalar *Unew)</td></tr>
<tr class="separator:a8ef8e65dda2bb15ed7cec0fbeb6a998a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44749d58166d3b77f1ce0022b6ba4cb5"><td class="memItemLeft" align="right" valign="top">arch_global void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a44749d58166d3b77f1ce0022b6ba4cb5">p0i</a> (int N_s, int N_E, int N_G, scalar refArea, int *sensors, scalar *phi_w, scalar *U, scalar *Unew)</td></tr>
<tr class="separator:a44749d58166d3b77f1ce0022b6ba4cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3af232bb566b8bb90429566b901232e"><td class="memItemLeft" align="right" valign="top">arch_global void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#ae3af232bb566b8bb90429566b901232e">hrl2D</a> (int N_s, int N_E, int N_G, int N_N, int order, scalar *XYZCen, scalar *powersXYZG, int *neighbors, int *TaylorDxIdx, int *TaylorDyIdx, scalar *weight, scalar refArea, scalar *A, scalar *Alim)</td></tr>
<tr class="separator:ae3af232bb566b8bb90429566b901232e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bee0bf5a2cbea3e35dc861b7c02dc0e"><td class="memItemLeft" align="right" valign="top">arch_global void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a4bee0bf5a2cbea3e35dc861b7c02dc0e">ChangeBasis</a> (int size1, int size2, int N_E, scalar *Transform, scalar *U, scalar *Unew)</td></tr>
<tr class="separator:a4bee0bf5a2cbea3e35dc861b7c02dc0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b03e104edb5d4f2a1760882b58e7607"><td class="memItemLeft" align="right" valign="top">arch_global void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a7b03e104edb5d4f2a1760882b58e7607">Prim2Cons</a> (int N_s, int N_E, scalar *U)</td></tr>
<tr class="separator:a7b03e104edb5d4f2a1760882b58e7607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ca77a4b27145bcb1f6638d2d1b4755"><td class="memItemLeft" align="right" valign="top">arch_global void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#aa3ca77a4b27145bcb1f6638d2d1b4755">Cons2Prim</a> (int N_s, int N_E, scalar *U)</td></tr>
<tr class="separator:aa3ca77a4b27145bcb1f6638d2d1b4755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08b6d825d6870856cd6e0903ffbb35d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#af08b6d825d6870856cd6e0903ffbb35d">Lstridedcopy</a> (int numblocks, int blocklen, int strideA, int strideB, int offsetA, int offsetB, scalar *A, scalar *B)</td></tr>
<tr class="separator:af08b6d825d6870856cd6e0903ffbb35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dda36b7cf079ae9d2d427a370606250"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a5dda36b7cf079ae9d2d427a370606250">Lreconstruct_energy</a> (int N_s, int N_E, int slicenum, scalar *rhoeLim, scalar *KLim, scalar *EMono, scalar *ELim)</td></tr>
<tr class="separator:a5dda36b7cf079ae9d2d427a370606250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c11828f99f4f21bba0be2dac08806c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#aa1c11828f99f4f21bba0be2dac08806c">Linternal_energy_multifluid</a> (int N_s, int N_E, int slicenum, scalar *p, scalar *g, scalar *rhoe)</td></tr>
<tr class="separator:aa1c11828f99f4f21bba0be2dac08806c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76289d972e1b6ff34a7d14c519719e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#ae76289d972e1b6ff34a7d14c519719e4">Linternal_energy_stiffened</a> (int N_s, int N_E, int slicenum, scalar *p, scalar *g, scalar *b, scalar *rhoe)</td></tr>
<tr class="separator:ae76289d972e1b6ff34a7d14c519719e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e9e943500f40c9151ee5e5bc74063f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#ab3e9e943500f40c9151ee5e5bc74063f">Lhrl1D</a> (int N_s, int N_E, int Nfields, int N_N, int slicenum, int *neighbors, int offxy, scalar *A, scalar *Alim)</td></tr>
<tr class="separator:ab3e9e943500f40c9151ee5e5bc74063f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3493f6335de6dd85074f56bdae5d7798"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a3493f6335de6dd85074f56bdae5d7798">Lhri1D</a> (int N_s, int N_E, int N_N, int *neighbors, int N_s1D, int slicenum, int offxy, scalar *Lag2Mono, scalar *Mono2Lag, int *sensor, scalar *U, scalar *Unew)</td></tr>
<tr class="separator:a3493f6335de6dd85074f56bdae5d7798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b223d9bad96629f35e2cf141e380863"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a6b223d9bad96629f35e2cf141e380863">Lm2i1D</a> (int N_s, int N_E, int N_N, int *neighbors, int N_s1D, int slicenum, int offxy, scalar *Lag2Mono, scalar *Mono2Lag, int *sensors, scalar *U, scalar *Unew)</td></tr>
<tr class="separator:a6b223d9bad96629f35e2cf141e380863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb292343416a95d1ccf54ce4d7a10c06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#adb292343416a95d1ccf54ce4d7a10c06">Lp0i</a> (int N_s, int N_E, int N_G, scalar refArea, int *sensors, scalar *phi_w, scalar *U, scalar *Unew)</td></tr>
<tr class="separator:adb292343416a95d1ccf54ce4d7a10c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80230d22a8ff9be931beb8a3fb400121"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a80230d22a8ff9be931beb8a3fb400121">Lhrl2D</a> (int N_s, int N_E, int N_G, int N_N, int order, scalar *XYZCen, scalar *powersXYZG, int *neighbors, int *TaylorDxIdx, int *TaylorDyIdx, scalar *weight, scalar refArea, scalar *A, scalar *Alim)</td></tr>
<tr class="separator:a80230d22a8ff9be931beb8a3fb400121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b106f02e42328299ba3753795519e88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a6b106f02e42328299ba3753795519e88">LChangeBasis</a> (int size1, int size2, int N_E, scalar *Transform, scalar *U, scalar *Unew)</td></tr>
<tr class="separator:a6b106f02e42328299ba3753795519e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3161a17757f26bafa2abbe340156e8e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a3161a17757f26bafa2abbe340156e8e2">LPrim2Cons</a> (int N_s, int N_E, scalar *U)</td></tr>
<tr class="separator:a3161a17757f26bafa2abbe340156e8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ed76a974ebd2f2ff900b305737f6d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="limiting__kernels_8cu.html#a77ed76a974ebd2f2ff900b305737f6d0">LCons2Prim</a> (int N_s, int N_E, scalar *U)</td></tr>
<tr class="separator:a77ed76a974ebd2f2ff900b305737f6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Kernels used by the <a class="el" href="classLimiting.html">Limiting</a> class. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) 2012-2015, Regents of the University of Michigan </dd></dl>
<dl class="section user"><dt>License:</dt><dd>This project is released under the GNU Public License. See LICENSE. </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Marc T. Henry de Frahan <a href="#" onclick="location.href='mai'+'lto:'+'mar'+'ch'+'df@'+'um'+'ich'+'.e'+'du'; return false;">march<span style="display: none;">.nosp@m.</span>df@u<span style="display: none;">.nosp@m.</span>mich.<span style="display: none;">.nosp@m.</span>edu</a>, Computational Flow Physics Laboratory, University of Michigan </dd></dl>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a5de1a5f1c0cf262e0ff2e5f03d586abc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MACRO</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">scalar* YL(x) = &amp;share[cnt]; cnt+=N_s; \</div>
<div class="line">      scalar* YC(x) = &amp;share[cnt]; cnt+=N_s;        \</div>
<div class="line">      scalar* YR(x) = &amp;share[cnt]; cnt+=N_s;</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5de1a5f1c0cf262e0ff2e5f03d586abc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MACRO</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;N_s; i++){YL(x)[i]  = U[(left *N_F+fcnt)*N_s+i];} \</div>
<div class="line">    for(<span class="keywordtype">int</span> i=0; i&lt;N_s; i++){YR(x)[i]  = U[(right*N_F+fcnt)*N_s+i];} fcnt++;</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac766dbf402ae6dba1b40a5c5a8825eb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_device void average_monomial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>Alim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a monomial, make all the slopes 0, return the average </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>monomial order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>monomial (1D) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Alim</td><td>monomial set to average in cell (slopes=0)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4c481ca08e0e44963f4b155f58214df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_device int binomial_coefficient </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binomial coefficient function </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>C(n,k) </dd></dl>
<h1><a class="anchor" id="Description"></a>
Description</h1>
<p>Inspired from <a href="https://gist.github.com/jeetsukumaran/5392166">https://gist.github.com/jeetsukumaran/5392166</a>. Does not handle super large numbers (no need really)</p>

</div>
</div>
<a class="anchor" id="a3b7ae4bf0d77b877b3793218f408ada8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_device scalar CellAvg </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ioff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&#160;</td>
          <td class="paramname"><em>refArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>powers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Not used right now. Get cell avg of a polynomial of order=order in a cell </p>
<dl class="section return"><dt>Returns</dt><dd>cell average </dd></dl>
<h1><a class="anchor" id="Description"></a>
Description</h1>
<p>ioff = 0 for full polynomial ioff = 3 for remainder polynomial</p>

</div>
</div>
<a class="anchor" id="a4bee0bf5a2cbea3e35dc861b7c02dc0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_global void ChangeBasis </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>Transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>Unew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Basis transformation (manual). Do not use this. Use BLAS </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size1</td><td>number of rows of tranform </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size2</td><td>number of columns of tranform </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_E</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Transform</td><td>Basis transform matrix (per element) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>solution to transform </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Unew</td><td>transformed solution</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa3ca77a4b27145bcb1f6638d2d1b4755"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_global void Cons2Prim </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform conserved variables to primitive variables </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s</td><td>number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_E</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>solution to transform</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13ee51de8e63390db9d4cdeacab06f85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_device void gemm </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-matrix mutliplication C = A*B </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>rows of A = rows of C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>columns of B = columns of C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>columns of A = rows of B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>first matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>second matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>C=A*B Assume column major order. Modeled on BLAS gemm.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd47ab65df79fa19b17efac085afd87a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_device void gemm3 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>C1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>C2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>B3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>C3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Three matrix-matrix mutliplications: C1 = A*B1, C2 = A*B2, C3 = A*B3 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>rows of A = rows of C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>columns of B = columns of C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">K</td><td>columns of A = rows of B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>first matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B1</td><td>second matrix (first gemm) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B2</td><td>second matrix (second gemm) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B3</td><td>second matrix (third gemm) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C1</td><td>C=A*B1 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C2</td><td>C=A*B2 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C3</td><td>C=A*B3 Assume column major order. Modeled on BLAS gemm.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afea1bee3e2f8ab6dedb101df367009e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_device void gemv </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-vector mutliplication C = A*B </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>rows of A = rows of C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>columns of A = rows of B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>first matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>second matrix </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>C=A*B Assume column major order. Modeled on BLAS gemv.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46545752cf7e2ea21dadfa32e45b9a9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_device void gemv3 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>B1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>C1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>B2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>C2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>B3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>C3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Three matrix-vector mutliplications: C1 = A*B1, C2 = A*B2, C3 = A*B3 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>rows of A = rows of C </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>columns of A = rows of B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>first matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B1</td><td>second matrix (first gemv) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B2</td><td>second matrix (second gemv) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B3</td><td>second matrix (third gemv) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C1</td><td>C=A*B1 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C2</td><td>C=A*B2 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C3</td><td>C=A*B3 Assume column major order. Modeled on BLAS gemv.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92518f2ffb1a46015396610a28b28ba9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_device void getTaylorDerivative </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>my</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>DxIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>DyIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>ddT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Not used right now</p>

</div>
</div>
<a class="anchor" id="a3d80df4d636f90befb57ed3866618c8a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_device void HR </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s1D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slicenum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>L2M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>M2L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>UL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>UC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>UR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>UMonoLim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Limit a nodal solution U using HR (1D decomposition) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s</td><td>number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>1D monomial order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s1D</td><td>number of nodes in 1D elemement </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slicenum</td><td>number of slices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L2M</td><td>Lagrange -&gt; Monomial transform </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M2L</td><td>Monomial -&gt; Lagrange transform </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmp</td><td>temporary array to store intermediate values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UL</td><td>solution on the left </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">UC</td><td>solution to be averaged </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">UR</td><td>solution on the right </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">UMonoLim</td><td>(optional) array to hold limited monomial values</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a511e708002c7b40970f0903239269fc5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_global void hri1D </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s1D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slicenum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>Lag2Mono</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>Mono2Lag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>Unew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HR limiting function for individual elements (assumes 1D decomposition) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s</td><td>number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_E</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_N</td><td>number of neighbors per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neighbors</td><td>array containing an element's neighbors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s1D</td><td>number of nodes in a slice (1D element) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slicenum</td><td>number of slices (in 2D N_s1D = slicenum) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offxy</td><td>offset if limiting in x or y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sensors</td><td>array of sensors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>solution to limit (Lagrange form) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Unew</td><td>limited solution (only some may be limited bc of sensor) Unew was necessary because you need to wait until all the elements have been limited before updating the solution.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7fd23b3c7c438e768f4ec1ea600d7e87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_global void hrl1D </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nfields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slicenum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>Alim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HR limiting function (assumes 1D decomposition) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s</td><td>number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_E</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nfields</td><td>number of fields to operate on (eg. one field instead of N_F) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_N</td><td>number of neighbors per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slicenum</td><td>to decompose higher dimensional problem into 1D slices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neighbors</td><td>array containing an element's neighbors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offxy</td><td>offset if limiting in x or y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>solution to limit (monomial form) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Alim</td><td>limited solution (monomial form)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae3af232bb566b8bb90429566b901232e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_global void hrl2D </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>XYZCen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>powersXYZG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>TaylorDxIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>TaylorDyIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&#160;</td>
          <td class="paramname"><em>refArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>Alim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Not used right now. HR limiting function fully 2D (eg. for triangles) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s</td><td>number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_E</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_G</td><td>number of gaussian nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_N</td><td>number of neighbors per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>DG order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">XYZCen</td><td>element centroid coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">powersXYZG</td><td>powers of coordinates of gaussian nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neighbors</td><td>array containing an element's neighbors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TaylorDxIdx</td><td>indices of Taylor polynomial derivatives in x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TaylorDyIdx</td><td>indices of Taylor polynomial derivatives in y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>gaussian integration weights </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">refArea</td><td>area of reference triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>solution to limit (monomial form) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Alim</td><td>limited solution (monomial form)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acfc91d42c8f0af8dd56a56ed12b83de6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">arch_device scalar integrate_monomial_derivative </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The integral of the kth derivative of nth order monomial (from -1 to 1) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>kth derivative of the polynomial </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>monomial order </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>${2}{(n-k+1)!}$ if n-k+1 is odd, 0 otherwise Calculates ${-1}^1 {^k}{ x^k} {x^n}{n!} {d} x$</dd></dl>

</div>
</div>
<a class="anchor" id="aa53b9b4a6c7794f2623344b129b18f62"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">arch_device scalar integrate_monomial_derivative_bounds </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The integral of the kth derivative of nth order monomial. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>kth derivative of the polynomial </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>monomial order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>lower integral bound </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>upper integral bound </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the integral Calculates ${a}^{b} {^k}{^k} {x^n}{n!} {d} x$</dd></dl>

</div>
</div>
<a class="anchor" id="aa7cc2e4f4ba2673dd8b464dfc4e5bbd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_device void internal_energy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s1D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slicenum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>rhoe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reconstruct the internal energy in monomial form </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s1D</td><td>number of nodes in 1D elemement </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slicenum</td><td>number of slices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>monomial pressure solution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>monomial 1/(gamma-1) solution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>monomial gamma*pinf/(gamma-1) solution </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rhoe</td><td>monomial internal energy </td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Description"></a>
Description</h1>
<p>Reconstruct the monomial internal energy coefficients using the pressure, 1/gamma-1, and gamma*pinf/(gamma-1) coefficients so that the pressure remains non-oscillatory</p>

</div>
</div>
<a class="anchor" id="a3739db4e71adf05a4bc800fc586ada30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_global void internal_energy_multifluid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slicenum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>rhoe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reconstruct the energy monomial coefficients </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s</td><td>number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_E</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slicenum</td><td>to decompose higher dimensional problem into 1D slices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>monomial pressure solution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>monomial 1/(gamma-1) solution </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rhoe</td><td>monomial internal energy </td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Description"></a>
Description</h1>
<p>Reconstruct the monomial internal energy coefficients using the pressure and 1/gamma-1 coefficients so that the pressure remains non-oscillatory</p>

</div>
</div>
<a class="anchor" id="ad4ad14f9400d6a279f0f872f98d59654"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_global void internal_energy_stiffened </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slicenum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>rhoe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reconstruct the energy monomial coefficients </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s</td><td>number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_E</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slicenum</td><td>to decompose higher dimensional problem into 1D slices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>monomial pressure solution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>monomial 1/(gamma-1) solution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>monomial gamma*pinf/(gamma-1) solution </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rhoe</td><td>monomial internal energy </td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Description"></a>
Description</h1>
<p>Reconstruct the monomial internal energy coefficients using the pressure, 1/gamma-1, and gamma*pinf/(gamma-1) coefficients so that the pressure remains non-oscillatory</p>

</div>
</div>
<a class="anchor" id="a465b3c0c1d5008036a258c93801914dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_device void kinetic_energy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>L2M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>rhou</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>rhov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>K</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the kinetic energy in monomial form </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s</td><td>number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L2M</td><td>Lagrange -&gt; Monomial transform </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rho</td><td>density (Lagrange form) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhou</td><td>x-momentum (Lagrange form) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhov</td><td>y-momentum (Lagrange form) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmp</td><td>temporary array to store intermediate values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">K</td><td>kinetic energy (Monomial form)</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b106f02e42328299ba3753795519e88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LChangeBasis </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>Transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>Unew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Host C function to launch ChangeBasis kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size1</td><td>number of rows of tranform </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size2</td><td>number of columns of tranform </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_E</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Transform</td><td>Basis transform matrix (per element) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>solution to transform </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Unew</td><td>transformed solution </td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Description"></a>
Description</h1>
<p>In GPU mode, launches N_E/blkE blocks of size1 x N_F x blkE threads. blkE controls the number of elements to set on each block</p>

</div>
</div>
<a class="anchor" id="a77ed76a974ebd2f2ff900b305737f6d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LCons2Prim </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Host C function to launch Cons2Prim kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s</td><td>number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_E</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>solution to transform </td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Description"></a>
Description</h1>
<p>In GPU mode, launches N_E/blkE blocks of N_s x 1 x blkE threads. blkE controls the number of elements to set on each block</p>

</div>
</div>
<a class="anchor" id="a3493f6335de6dd85074f56bdae5d7798"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lhri1D </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s1D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slicenum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>Lag2Mono</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>Mono2Lag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>Unew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>HR limiting function for individual elements (assumes 1D decomposition) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s</td><td>number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_E</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_N</td><td>number of neighbors per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neighbors</td><td>array containing an element's neighbors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s1D</td><td>number of nodes in a slice (1D element) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slicenum</td><td>number of slices (in 2D N_s1D = slicenum) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offxy</td><td>offset if limiting in x or y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sensors</td><td>array of sensors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>solution to limit (Lagrange form) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Unew</td><td>limited solution (only some may be limited bc of sensor) </td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Description"></a>
Description</h1>
<p>In GPU mode, launches N_E blocks of 1 x N_F x 1 threads.</p>

</div>
</div>
<a class="anchor" id="ab3e9e943500f40c9151ee5e5bc74063f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lhrl1D </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nfields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slicenum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>Alim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Host C function to launch hrl1D kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s</td><td>number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_E</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Nfields</td><td>number of fields to operate on (eg. one field instead of N_F) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_N</td><td>number of neighbors per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slicenum</td><td>to decompose higher dimensional problem into 1D slices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neighbors</td><td>array containing an element's neighbors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offxy</td><td>offset if limiting in x or y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>solution to limit (monomial form) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Alim</td><td>limited solution (monomial form) </td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Description"></a>
Description</h1>
<p>In GPU mode, launches N_E/blkE blocks of slicenum x Nfields x blkE threads. blkE controls the number of elements to set on each block</p>

</div>
</div>
<a class="anchor" id="a80230d22a8ff9be931beb8a3fb400121"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lhrl2D </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>XYZCen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>powersXYZG</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>TaylorDxIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>TaylorDyIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&#160;</td>
          <td class="paramname"><em>refArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>Alim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Host C function to launch hrl2D kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s</td><td>number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_E</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_G</td><td>number of gaussian nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_N</td><td>number of neighbors per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>DG order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">XYZCen</td><td>element centroid coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">powersXYZG</td><td>powers of coordinates of gaussian nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neighbors</td><td>array containing an element's neighbors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TaylorDxIdx</td><td>indices of Taylor polynomial derivatives in x </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">TaylorDyIdx</td><td>indices of Taylor polynomial derivatives in y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>gaussian integration weights </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">refArea</td><td>area of reference triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>solution to limit (monomial form) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Alim</td><td>limited solution (monomial form) </td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Description"></a>
Description</h1>
<p>In GPU mode, launches N_E/blkE blocks of 1 x N_F x blkE threads. blkE controls the number of elements to set on each block</p>

</div>
</div>
<a class="anchor" id="a185f5abaa2b3c3d3c5614daa9b5032cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_device int lim_factorial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Factorial function </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>get factorial of this number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>factorial of n</dd></dl>

</div>
</div>
<a class="anchor" id="a70986f580b196eef16d7cb91e47b6924"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_device void limit_monomial </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>AL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>AC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>AR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>Alim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Limit a 1D monomial using HR </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>monomial order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AL</td><td>left cell monomial </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AC</td><td>center cell monomial </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">AR</td><td>right cell monomial </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Alim</td><td>limited center cell monomial</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa1c11828f99f4f21bba0be2dac08806c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Linternal_energy_multifluid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slicenum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>rhoe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Host C function to lauch internal_energy_multifluid kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s</td><td>number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_E</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slicenum</td><td>to decompose higher dimensional problem into 1D slices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>monomial pressure solution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>monomial 1/(gamma-1) solution </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rhoe</td><td>monomial internal energy </td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Description"></a>
Description</h1>
<p>In GPU mode, launches N_E/blkE blocks of N_s x slicenum x blkE threads. blkE controls the number of elements to set on each block</p>

</div>
</div>
<a class="anchor" id="ae76289d972e1b6ff34a7d14c519719e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Linternal_energy_stiffened </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slicenum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>rhoe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Host C function to lauch internal_energy_multifluid kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s</td><td>number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_E</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slicenum</td><td>to decompose higher dimensional problem into 1D slices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>monomial pressure solution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">g</td><td>monomial 1/(gamma-1) solution </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>monomial gamma*pinf/(gamma-1) solution </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rhoe</td><td>monomial internal energy </td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Description"></a>
Description</h1>
<p>In GPU mode, launches N_E/blkE blocks of N_s x slicenum x blkE threads. blkE controls the number of elements to set on each block</p>

</div>
</div>
<a class="anchor" id="a6b223d9bad96629f35e2cf141e380863"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lm2i1D </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s1D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slicenum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>Lag2Mono</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>Mono2Lag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>Unew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modified limiting function for individual elements (assumes 1D decomposition) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s</td><td>number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_E</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_N</td><td>number of neighbors per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neighbors</td><td>array containing an element's neighbors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s1D</td><td>number of nodes in a slice (1D element) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slicenum</td><td>number of slices (in 2D N_s1D = slicenum) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offxy</td><td>offset if limiting in x or y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sensors</td><td>array of sensors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>solution to limit (Lagrange form) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Unew</td><td>limited solution (only some may be limited bc of sensor) </td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Description"></a>
Description</h1>
<p>In GPU mode, launches N_E blocks of 1 x 1 x 1 threads.</p>

</div>
</div>
<a class="anchor" id="adb292343416a95d1ccf54ce4d7a10c06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lp0i </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&#160;</td>
          <td class="paramname"><em>refArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>phi_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>Unew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modified limiting function for individual elements (assumes 1D decomposition) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s</td><td>number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_E</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_G</td><td>number of integration points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">refArea</td><td>area of reference triangle </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sensors</td><td>array of sensors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phi_w</td><td>matrix of basis function for collocation (premultiplied by integration weights) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>solution to limit (Lagrange form) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Unew</td><td>limited solution (only some may be limited bc of sensor) </td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Description"></a>
Description</h1>
<p>In GPU mode, launches numblocks/blkE blocks of blocklen x 1 x blkE threads. blkE controls the number of elements to set on each block</p>

</div>
</div>
<a class="anchor" id="a3161a17757f26bafa2abbe340156e8e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LPrim2Cons </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Host C function to launch Prim2Cons kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s</td><td>number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_E</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>solution to transform </td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Description"></a>
Description</h1>
<p>In GPU mode, launches N_E/blkE blocks of N_s x 1 x blkE threads. blkE controls the number of elements to set on each block</p>

</div>
</div>
<a class="anchor" id="a5dda36b7cf079ae9d2d427a370606250"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lreconstruct_energy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slicenum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>rhoeLim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>KLim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>EMono</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>ELim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Host C function to lauch reconstruct_energy kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s</td><td>number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_E</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slicenum</td><td>to decompose higher dimensional problem into 1D slices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhoeLim</td><td>limited monomial internal energy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KLim</td><td>limited monomial kinetic energy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EMono</td><td>monomial total energy </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ELim</td><td>limited monomial total energy </td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Description"></a>
Description</h1>
<p>In GPU mode, launches N_E/blkE blocks of slicenum x 1 x blkE threads. blkE controls the number of elements to set on each block</p>

</div>
</div>
<a class="anchor" id="af08b6d825d6870856cd6e0903ffbb35d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lstridedcopy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numblocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blocklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>strideA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>strideB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offsetA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offsetB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Host C function to lauch stridedcopy kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numblocks</td><td>number of blocks to copy from A to B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blocklen</td><td>number of elements in each block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strideA</td><td>number of elements between start of each block in A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strideB</td><td>number of elements between start of each block in B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsetA</td><td>number of elements to skip at start of A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsetB</td><td>number of elements to skip at start of B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>source array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>destination array </td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Description"></a>
Description</h1>
<p>In GPU mode, launches numblocks/blkE blocks of blocklen x 1 x blkE threads. blkE controls the number of elements to set on each block</p>

</div>
</div>
<a class="anchor" id="a8ef8e65dda2bb15ed7cec0fbeb6a998a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_global void m2i1D </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s1D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slicenum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>Lag2Mono</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>Mono2Lag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>Unew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modified limiting function for individual elements (assumes 1D decomposition) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s</td><td>number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_E</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_N</td><td>number of neighbors per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">neighbors</td><td>array containing an element's neighbors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s1D</td><td>number of nodes in a slice (1D element) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slicenum</td><td>number of slices (in 2D N_s1D = slicenum) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offxy</td><td>offset if limiting in x or y </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sensors</td><td>array of sensors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>solution to limit (Lagrange form) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Unew</td><td>limited solution (only some may be limited bc of sensor) Unew was necessary because you need to wait until all the elements have been limited before updating the solution.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a17d976266542e5fef94a9c0bbcdaf4f4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">arch_device scalar minabs </td>
          <td>(</td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Minimum of the absolute value of c </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>array to find minabs of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements in c </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>minabs of c</dd></dl>

</div>
</div>
<a class="anchor" id="a0069af8bc38d2f4e9ec19bf9df6be4ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_device scalar minmod </td>
          <td>(</td>
          <td class="paramtype">scalar&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Minmod function for 2 arguments </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>first arg </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>second arg </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>minmod(a,b) </dd></dl>
<h1><a class="anchor" id="Description"></a>
Description</h1>
<p>eq 2.19 of "Hierarchical reconstruction for discontinuous Galerkin methods..."</p>

</div>
</div>
<a class="anchor" id="aafe1b556285d628a4b92b14110991cb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_device scalar minmod </td>
          <td>(</td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generalized minmod function </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>array to find minmod of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements in c </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>minmod of c </dd></dl>
<h1><a class="anchor" id="Description"></a>
Description</h1>
<p>eq 2.19 of "Hierarchical reconstruction for discontinuous Galerkin methods..."</p>

</div>
</div>
<a class="anchor" id="aa0243447010f74e6a50a8c225ae3d616"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_device scalar minmod2 </td>
          <td>(</td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generalized minmod function (alternate) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>array to find minmod of </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of elements in c </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>minmod of c </dd></dl>
<h1><a class="anchor" id="Description"></a>
Description</h1>
<p>eq 2.20 of "Hierarchical reconstruction for discontinuous Galerkin methods..."</p>

</div>
</div>
<a class="anchor" id="a44749d58166d3b77f1ce0022b6ba4cb5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_global void p0i </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar&#160;</td>
          <td class="paramname"><em>refArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>sensors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>phi_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>Unew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>p=0 limiting function for individual elements (assumes 1D decomposition) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s</td><td>number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_E</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_G</td><td>number of integration points </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">refArea</td><td>area of reference element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sensors</td><td>array of sensors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">phi_w</td><td>matrix of basis function for collocation (premultiplied by integration weights) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>solution to limit (Lagrange form) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">Unew</td><td>limited solution (only some may be limited bc of sensor) Unew was necessary because you need to wait until all the elements have been limited before updating the solution.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7dfe81005a75c2551569cf06f784bc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_device void pressure </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>rhou</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>rhov</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>gamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the pressure in an individual element </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s</td><td>number of nodes in an element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rho</td><td>density </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhou</td><td>x-momentum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhov</td><td>y-momentum </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>total energy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gamma</td><td>1/(gamma-1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">beta</td><td>pinf*gamma/(gamma-1) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p</td><td>pressure</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7b03e104edb5d4f2a1760882b58e7607"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_global void Prim2Cons </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>U</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform primitive variables to conserved variables </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s</td><td>number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_E</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">U</td><td>solution to transform</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0baf0fa343897a168db374263509330c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_global void reconstruct_energy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slicenum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>rhoeLim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>KLim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>EMono</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>ELim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reconstruct the energy monomial coefficients </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s</td><td>number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_E</td><td>number of elements </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slicenum</td><td>to decompose higher dimensional problem into 1D slices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhoeLim</td><td>limited monomial internal energy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KLim</td><td>limited monomial kinetic energy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EMono</td><td>monomial total energy </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ELim</td><td>limited monomial total energy </td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Description"></a>
Description</h1>
<p>Reconstruct the energy monomial coefficients using the internal and kinetic energy monomial coefficients. Apply a correction to the zeroth coefficients so that the method is conservative.</p>

</div>
</div>
<a class="anchor" id="afbe1be35043c65e0741b29492605671b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_device void reconstruct_total_energy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s1D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slicenum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>L2M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>M2L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>rhoeLim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>KLim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reconstruct the energy lagrange polynomial for an individual element </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s</td><td>number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s1D</td><td>number of nodes per slice </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhoeLim</td><td>limited monomial internal energy </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">KLim</td><td>limited monomial kinetic energy </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">E</td><td>limited total energy (lagrange form) </td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Description"></a>
Description</h1>
<p>Reconstruct the energy Lagrange coefficients using the internal and kinetic energy monomial coefficients. Apply a correction to the zeroth coefficients so that the method is conservative.</p>

</div>
</div>
<a class="anchor" id="a7af2f34a5759f1b77e868ab2e5745c23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_device void set2average </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N_s1D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>slicenum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>L2M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>M2L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>UMonoLim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a nodal solution U to its cell average (1D slices) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s</td><td>number of nodes per element </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>1D monomial order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N_s1D</td><td>number of nodes in 1D elemement </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slicenum</td><td>number of slices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">L2M</td><td>Lagrange -&gt; Monomial transform </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">M2L</td><td>Monomial -&gt; Lagrange transform </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmp</td><td>temporary array to store intermediate values </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">U</td><td>solution to be averaged </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">UMonoLim</td><td>(optional) array to hold limited monomial values</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abde8e1c7130bbae601ca57cfd9a9d711"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arch_global void stridedcopy </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numblocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blocklen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>strideA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>strideB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offsetA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offsetB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">scalar *&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Strided copy of array A (length&gt;= numblocks*strideA) to array B (length&gt;= numblocks*strideB) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numblocks</td><td>number of blocks to copy from A to B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blocklen</td><td>number of elements in each block </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strideA</td><td>number of elements between start of each block in A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">strideB</td><td>number of elements between start of each block in B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsetA</td><td>number of elements to skip at start of A </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offsetB</td><td>number of elements to skip at start of B </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>source array </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>destination array </td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="Description"></a>
Description</h1>
<p>Modeled on MPI_Type_Vector</p>
<p>You can test with this segment of code: scalar* a = new scalar[18]; scalar* b = new scalar[6]; for(int i=0; i&lt;18; i++){a[i] = i;printf("%i %f\n",i,a[i]);} scalar* d_a; scalar* d_b; cudaMalloc((void**) &amp;d_a,18*sizeof(scalar)); cudaMalloc((void**) &amp;d_b,6*sizeof(scalar)); cudaMemcpy(d_a, a, 18*sizeof(scalar), cudaMemcpyHostToDevice); Lstridedcopy(2,3,9,3,0,0,d_a,d_b); cudaMemcpy(b, d_b, 6*sizeof(scalar), cudaMemcpyDeviceToHost); for(int i=0; i&lt;6; i++){printf("%i: %f\n",i,b[i]);} delete[] a; delete[] b; exit(0);</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Aug 22 2017 12:58:50 for dg by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
