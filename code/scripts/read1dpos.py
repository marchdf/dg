######################################################################
#
# Function to read a 1D .pos file generated by gmsh
# Useful to plot stuff from a 1D simulation
#
# Returns gaussian interpolation of the data at time T
#
######################################################################

from numpy import *
from gaussxw import *

def read1dpos(fname,T):

    dat = loadtxt(fname)
    nt  = dat[:,0]        # extract the time step list
    dt  = dat[:,1]        # extract time step list
    el  = dat[:,3]        # extract the element list
    N_t = nt.max(0)+1     # number of time steps + 1 to account for initial
    N_E = el.max(0)+1     # number of elements
    N_x = dat.shape[1]/8  # number of x in an element 8 columns per element
    order = N_x-1
 
    ind = argmin(abs(dt-T))  # get the indexes at the time we want to plot
    ind = range(ind,int(ind+N_E)) # grab all the elements at that time

    x       = zeros(N_E*N_x)
    y       = zeros(N_E*N_x)
    indx    = range(4,dat.shape[1],8)       # index for x position
    indy    = range(7,dat.shape[1],8)       # index for y data
    indsort = argsort(dat[ind[0],indx])  # index for sorting x in ascending order

    xgauss  = zeros(N_E*N_x)
    ygauss  = zeros(N_E*N_x)

    for i in range(0,int(N_E)):
        x[i*N_x:(i*N_x+N_x)] = dat[ind[i],indx][indsort]
        y[i*N_x:(i*N_x+N_x)] = dat[ind[i],indy][indsort]
        xtmp,wtmp = gaussxwab(N_x,x[i*N_x],x[i*N_x+N_x-1])
        xgauss[i*N_x:(i*N_x+N_x)] = xtmp[ ::-1] # fliplr
        ygauss[i*N_x:(i*N_x+N_x)]   = polyval(polyfit(x[i*N_x:(i*N_x+N_x)],y[i*N_x:(i*N_x+N_x)],order),xgauss[i*N_x:(i*N_x+N_x)])

    return xgauss,ygauss

def readxtpos(fname):

    dat = loadtxt(fname)
    nt  = dat[:,0]        # extract the time step list (number)
    dt  = dat[:,1]        # extract time step list (value)
    el  = dat[:,3]        # extract the element list
    N_t = nt.max(0)+1     # number of time steps + 1 to account for initial
    N_E = el.max(0)+1     # number of elements
    N_x = dat.shape[1]/8  # number of x in an element 8 columns per element
    order = N_x-1
 
    x       = zeros(N_E*N_x)
    y       = zeros(N_E*N_x)
    xgauss  = zeros(N_E*N_x)
    ygauss  = zeros(N_E*N_x)
    indx    = range(4,dat.shape[1],8)       # index for x position
    indy    = range(7,dat.shape[1],8)       # index for y data
    time = dt[ ::N_E];
    YY = zeros((len(time),len(xgauss)));

    for cnt,T in enumerate(time):
        ind = nonzero(dt==T)                    # get the indexes at the time we want to plot
        indsort = argsort(dat[ind[0][0],indx])  # index for sorting x in ascending order
        print cnt, T

        for i in range(0,int(N_E)):
            x[i*N_x:(i*N_x+N_x)] = dat[ind[0][i],indx][indsort]
            y[i*N_x:(i*N_x+N_x)] = dat[ind[0][i],indy][indsort]
            xtmp,wtmp = gaussxwab(N_x,x[i*N_x],x[i*N_x+N_x-1])
            xgauss[i*N_x:(i*N_x+N_x)] = xtmp[ ::-1] # fliplr
            ygauss[i*N_x:(i*N_x+N_x)]   = polyval(polyfit(x[i*N_x:(i*N_x+N_x)],y[i*N_x:(i*N_x+N_x)],order),xgauss[i*N_x:(i*N_x+N_x)])

        YY[cnt,:] = ygauss

    return xgauss,YY,time
